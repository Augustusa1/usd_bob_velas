<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análisis de Mercado Forex - USD/BOB (Datos Reales)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');

        body {
            font-family: 'Roboto Mono', monospace;
            background-color: #131722;
            color: #D1D4DC;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            font-size: 2rem;
            color: #FFFFFF;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(0, 150, 255, 0.5);
        }

        p {
            font-size: 0.9rem;
            color: #787B86;
            margin-top: 0;
            margin-bottom: 20px;
        }

        #chart-container {
            position: relative;
            background-color: #1A1E29;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 1200px;
            box-sizing: border-box;
        }

        .axis-label {
            fill: #B2B5BE;
            font-size: 12px;
            text-anchor: middle;
        }

        .tick line {
            stroke: #2A2E39;
            stroke-dasharray: 2,2;
        }

        .tick text {
            fill: #787B86;
            font-size: 11px;
        }

        .domain {
            stroke: #494949;
        }
        
        .tooltip {
            position: absolute;
            text-align: left;
            padding: 10px;
            font-size: 12px;
            background: #2A2E39;
            border: 1px solid #363A45;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            color: #D1D4DC;
            white-space: nowrap;
        }
        .tooltip-date {
            font-weight: bold;
            margin-bottom: 5px;
            color: #FFFFFF;
        }
        .tooltip-info span {
            display: inline-block;
            min-width: 50px;
            font-weight: bold;
        }
        .tooltip-info .value {
            font-weight: normal;
            margin-left: 5px;
        }
        .color-up { color: #26A69A; }
        .color-down { color: #EF5350; }
        
        .crosshair {
            stroke: #787B86;
            stroke-width: 1px;
            stroke-dasharray: 3,3;
        }

    </style>
</head>
<body>

    <h1>Análisis de Mercado Forex - USD/BOB</h1>
    <p>Datos reales del par de divisas USD/BOB. Utiliza el scroll para hacer zoom y arrastra para navegar.</p>

    <div id="chart-container">
        <svg id="candlestick-chart"></svg>
    </div>

    <script>
        // --- CHART SETUP ---
        const container = document.getElementById('chart-container');
        const margin = {top: 20, right: 60, bottom: 40, left: 60};
        let width, height;

        const svg = d3.select("#candlestick-chart");
        const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
        
        let processedData = []; // Para almacenar los datos cargados y procesados

        // --- DATA LOADING AND PROCESSING ---
        // Parseador para la fecha y hora combinadas
        const parseDateTime = d3.timeParse("%Y-%m-%d %H:%M:%S");

        // Cargar el archivo CSV
        d3.csv("data.csv").then(data => { // Asegúrate que 'data.csv' sea el nombre correcto de tu archivo
            processedData = data.map(d => {
                // Combinar Fecha y HORA para crear un solo objeto Date
                const dateTimeStr = `${d.Fecha} ${d.HORA}`;
                return {
                    date: parseDateTime(dateTimeStr),
                    open: +d.OPEN,  // El '+' convierte a número
                    high: +d.MAX,
                    low: +d.MIN,
                    close: +d.CLOSE
                };
            }).filter(d => d.date && !isNaN(d.open) && !isNaN(d.high) && !isNaN(d.low) && !isNaN(d.close)); // Filtra entradas inválidas

            // Ordenar los datos por fecha para asegurar que el gráfico se dibuje correctamente
            processedData.sort((a, b) => a.date - b.date);

            // Una vez que los datos están cargados y procesados, dibuja el gráfico
            drawChart();
            console.log("Datos cargados y procesados:", processedData);

            // --- Ejemplo de uso de la función findClosestCandleToTime con tus datos reales ---
            // Asumiendo que quieres encontrar la vela más cercana a las 17:00 del último día de tus datos
            if (processedData.length > 0) {
                const lastDateInDataset = processedData[processedData.length - 1].date;
                const targetDateForSearch = new Date(lastDateInDataset.getFullYear(), lastDateInDataset.getMonth(), lastDateInDataset.getDate());
                
                const closestCandle1700 = findClosestCandleToTime(processedData, targetDateForSearch, 17, 0, 0);

                if (closestCandle1700) {
                    console.log(`Vela más cercana a las 17:00 del ${d3.timeFormat("%d/%m/%Y")(targetDateForSearch)}:`);
                    console.log("Fecha/Hora:", d3.timeFormat("%Y-%m-%d %H:%M:%S")(closestCandle1700.date));
                    console.log("Open:", closestCandle1700.open.toFixed(3));
                    console.log("High:", closestCandle1700.high.toFixed(3));
                    console.log("Low:", closestCandle1700.low.toFixed(3));
                    console.log("Close:", closestCandle1700.close.toFixed(3));
                } else {
                    console.log(`No se encontró una vela para la fecha ${d3.timeFormat("%d/%m/%Y")(targetDateForSearch)} o en el rango especificado.`);
                }
            }

        }).catch(error => {
            console.error('Error al cargar o procesar el CSV:', error);
            document.getElementById('chart-container').innerHTML = '<p style="color: red;">Error al cargar los datos del gráfico. Asegúrate de que el archivo CSV exista y tenga el formato correcto.</p>';
        });


        // --- NEW FUNCTION: Find the closest candle to a specific time on a given date ---
        function findClosestCandleToTime(data, targetDate, targetHour, targetMinute, targetSecond) {
            const targetTimeMillis = (targetHour * 3600 + targetMinute * 60 + targetSecond) * 1000; 

            let closestCandle = null;
            let minDifference = Infinity;

            data.forEach(d => {
                const candleDate = new Date(d.date);
                // Asegurarse de comparar solo la parte de la fecha (año, mes, día)
                if (candleDate.getFullYear() === targetDate.getFullYear() &&
                    candleDate.getMonth() === targetDate.getMonth() &&
                    candleDate.getDate() === targetDate.getDate()) {
                    
                    const candleTimeMillis = (candleDate.getHours() * 3600 + candleDate.getMinutes() * 60 + candleDate.getSeconds()) * 1000;
                    const difference = Math.abs(candleTimeMillis - targetTimeMillis);

                    // Para el valor más reciente en un rango de tiempo, podrías ordenar primero
                    // y luego tomar el último, pero para 'el más cercano', este enfoque es directo.
                    // Si buscas el más reciente EN ese rango (ej. 17:00-17:59),
                    // primero filtra por rango, y luego ordena por fecha/hora descendente y toma el primero.

                    if (difference < minDifference) {
                        minDifference = difference;
                        closestCandle = d;
                    }
                }
            });
            return closestCandle;
        }

        // --- SCALES & AXES ---
        const x = d3.scaleBand().padding(0.2);
        const y = d3.scaleLinear();
        // Ajustar el formato del tick del eje X para mostrar Fecha y Hora
        const xAxis = d3.axisBottom(x).tickFormat(d3.timeFormat("%d-%b %H:%M")); 
        const yAxis = d3.axisLeft(y).tickFormat(d => `${d.toFixed(3)}`); // Aumentar precisión si es necesario
        
        const xAxisGroup = g.append("g").attr("class", "x-axis");
        const yAxisGroup = g.append("g").attr("class", "y-axis");
        const yGridLines = g.append("g").attr('class', 'grid');
        const yAxisLabel = g.append("text").attr("class", "axis-label");
        
        // --- UI ELEMENTS ---
        const clipPath = svg.append("defs").append("clipPath").attr("id", "clip").append("rect");
        const chartBody = g.append("g").attr("clip-path", "url(#clip)");
        const tooltip = d3.select("body").append("div").attr("class", "tooltip");
        const crosshair = g.append('g').style('display', 'none');
        crosshair.append('line').attr('class', 'crosshair crosshair-x');
        crosshair.append('line').attr('class', 'crosshair crosshair-y');
        
        let lastTransform = d3.zoomIdentity;
        const interactionRect = g.append("rect").style("fill", "none").style("pointer-events", "all");
        
        // --- DRAWING FUNCTION ---
        function drawChart() {
            // Solo dibujar si processedData tiene elementos
            if (processedData.length === 0) {
                console.warn("No hay datos para dibujar el gráfico.");
                return;
            }

            width = container.clientWidth - margin.left - margin.right;
            height = (container.clientWidth * 0.5 > 600 ? 600 : container.clientWidth * 0.5) - margin.top - margin.bottom;
            
            svg.attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom);
            clipPath.attr("width", width).attr("height", height);
            interactionRect.attr("width", width).attr("height", height);

            x.domain(processedData.map(d => d.date)).range([0, width]);
            
            const yMin = d3.min(processedData, d => d.low);
            const yMax = d3.max(processedData, d => d.high);

            if (yMin !== undefined && yMax !== undefined) {
                const padding = (yMax - yMin) * 0.1 || yMin * 0.1; 
                y.domain([yMin - padding, yMax + padding]).range([height, 0]);
            } else {
                y.domain([8.9, 9.5]).range([height, 0]); // Default domain si los datos están vacíos
            }
            
            yAxisLabel
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15)
                .attr("x", 0 - (height / 2))
                .text("Precio (Bs por USD)");

            xAxisGroup.attr("transform", `translate(0,${height})`).call(xAxis);
            yAxisGroup.call(yAxis);
            yGridLines.call(d3.axisLeft(y).tickSize(-width).tickFormat("")).selectAll("line").attr("class", "tick");
            yGridLines.select(".domain").remove();
            
            updateTicks(); 

            chartBody.selectAll("g.candle").remove(); // Limpiar velas antiguas antes de redibujar
            const candles = chartBody.selectAll("g.candle").data(processedData, d => d.date).enter().append("g").attr("class", "candle");
            candles.append("line").attr("class", "wick");
            candles.append("rect").attr("class", "body");
            updateCandlePositions(x);

            svg.call(zoom.transform, d3.zoomIdentity);
        }
        
        function updateCandlePositions(scale) {
             g.selectAll(".candle .wick")
                .attr("x1", d => scale(d.date) + scale.bandwidth() / 2).attr("x2", d => scale(d.date) + scale.bandwidth() / 2)
                .attr("y1", d => y(d.high)).attr("y2", d => y(d.low))
                .attr("stroke", d => d.close >= d.open ? "#26A69A" : "#EF5350");
                
            g.selectAll(".candle .body")
                .attr("x", d => scale(d.date)).attr("y", d => y(Math.max(d.open, d.close)))
                .attr("width", scale.bandwidth()).attr("height", d => Math.abs(y(d.open) - y(d.close)) || 1)
                .attr("fill", d => d.close >= d.open ? "#26A69A" : "#EF5350");
        }

        function updateTicks(scale) {
            if (!scale) scale = x;
            const tickCount = Math.floor(width / 120); // Número aproximado de ticks

            // Obtener todas las fechas visibles
            const visibleDataDates = processedData
                .filter(d => {
                    const pos = scale(d.date);
                    return pos !== undefined && pos >= 0 && pos < width;
                })
                .map(d => d.date);
            
            // Si no hay datos visibles, salir
            if (visibleDataDates.length === 0) {
                xAxis.tickValues([]);
                xAxisGroup.call(xAxis.scale(scale));
                return;
            }

            // D3 time ticks para mejor manejo de fechas y horas
            const timeInterval = d3.timeMinute.every(30); // Mostrar ticks cada 30 minutos, ajusta según tu densidad
            const tickValues = timeInterval.range(visibleDataDates[0], d3.timeMinute.offset(visibleDataDates[visibleDataDates.length - 1], 1));
            
            xAxis.tickValues(tickValues);
            xAxisGroup.call(xAxis.scale(scale));
        }


        // --- INTERACTION HANDLERS ---
        function handleMouseMove(event) {
            if(processedData.length === 0) return;
            const logicalX = lastTransform.invertX(d3.pointer(event)[0]);
            
            // Encuentra la fecha más cercana al puntero
            const closestDate = x.domain().reduce((prev, curr) => {
                return (Math.abs(x(curr) + x.bandwidth() / 2 - logicalX) < Math.abs(x(prev) + x.bandwidth() / 2 - logicalX) ? curr : prev);
            });
            
            // Encuentra el objeto de datos correspondiente a esa fecha
            const d = processedData.find(item => item.date.getTime() === closestDate.getTime());
            
            if (!d) return;

            const [mx, my] = d3.pointer(event);
            const currentXScale = lastTransform.rescaleX(x);
            crosshair.style('display', null);
            crosshair.select('.crosshair-x').attr('x1', 0).attr('x2', width).attr('y1', my).attr('y2', my);
            const crosshairCenterX = currentXScale(d.date) + currentXScale.bandwidth() / 2;
            crosshair.select('.crosshair-y').attr('x1', crosshairCenterX).attr('x2', crosshairCenterX).attr('y1', 0).attr('y2', height);
            
            tooltip.style("opacity", .9);
            const colorClass = d.close >= d.open ? "color-up" : "color-down";
            tooltip.html(`
                <div class="tooltip-date">${d3.timeFormat("%A, %b %d, %Y - %H:%M:%S")(d.date)}</div>
                <div class="tooltip-info">
                    <span class="${colorClass}">Open:</span><span class="value">${d.open.toFixed(4)}</span><br>
                    <span class="${colorClass}">High:</span><span class="value">${d.high.toFixed(4)}</span><br>
                    <span class="${colorClass}">Low:</span><span class="value">${d.low.toFixed(4)}</span><br>
                    <span class="${colorClass}">Close:</span><span class="value">${d.close.toFixed(4)}</span>
                </div>
            `).style("left", (event.pageX + 15) + "px").style("top", (event.pageY - 28) + "px");
        }

        function handleMouseOut() {
            tooltip.style("opacity", 0);
            crosshair.style('display', 'none');
        }

        // --- ZOOM ---
        function zoomed(event) {
            lastTransform = event.transform;
            const newX = lastTransform.rescaleX(x);
            updateCandlePositions(newX);
            updateTicks(newX);
        }

        const zoom = d3.zoom().scaleExtent([0.5, 50]).translateExtent([[-width, -Infinity], [width * 10, Infinity]]).on("zoom", zoomed);
        // Aplica el zoom al svg entero
        svg.call(zoom); 
        // El interactionRect para detectar movimientos de mouse y tooltips
        interactionRect.on("mousemove", handleMouseMove).on("mouseout", handleMouseOut);

        // --- INITIALIZATION ---
        // drawChart() ahora se llama dentro del .then() de d3.csv
        window.addEventListener('resize', drawChart);

    </script>
</body>
</html>
