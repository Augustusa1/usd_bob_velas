<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Análisis de Mercado Forex - USD/BOB (Velas Diarias)</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap');

        body {
            font-family: 'Roboto Mono', monospace;
            background-color: #131722;
            color: #D1D4DC;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            font-size: 2rem;
            color: #FFFFFF;
            margin-bottom: 5px;
            text-shadow: 0 0 10px rgba(0, 150, 255, 0.5);
        }

        p {
            font-size: 0.9rem;
            color: #787B86;
            margin-top: 0;
            margin-bottom: 20px;
        }

        #chart-container {
            position: relative;
            background-color: #1A1E29;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 1200px;
            box-sizing: border-box;
        }

        .axis-label {
            fill: #B2B5BE;
            font-size: 12px;
            text-anchor: middle;
        }

        .tick line {
            stroke: #2A2E39;
            stroke-dasharray: 2,2;
        }

        .tick text {
            fill: #787B86;
            font-size: 11px;
        }

        .domain {
            stroke: #494949;
        }
        
        .tooltip {
            position: absolute;
            text-align: left;
            padding: 10px;
            font-size: 12px;
            background: #2A2E39;
            border: 1px solid #363A45;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            color: #D1D4DC;
            white-space: nowrap;
        }
        .tooltip-date {
            font-weight: bold;
            margin-bottom: 5px;
            color: #FFFFFF;
        }
        .tooltip-info span {
            display: inline-block;
            min-width: 50px;
            font-weight: bold;
        }
        .tooltip-info .value {
            font-weight: normal;
            margin-left: 5px;
        }
        .color-up { color: #26A69A; }
        .color-down { color: #EF5350; }
        
        .crosshair {
            stroke: #787B86;
            stroke-width: 1px;
            stroke-dasharray: 3,3;
        }

    </style>
</head>
<body>

    <h1>Análisis de Mercado Forex - USD/BOB (Velas Diarias)</h1>
    <p>Datos reales del par de divisas USD/BOB. Utiliza el scroll para hacer zoom y arrastra para navegar.</p>

    <div id="chart-container">
        <svg id="candlestick-chart"></svg>
    </div>

    <script>
        // --- CHART SETUP ---
        const container = document.getElementById('chart-container');
        const margin = {top: 20, right: 60, bottom: 40, left: 60};
        let width, height;

        const svg = d3.select("#candlestick-chart");
        const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
        
        let processedData = []; // Para almacenar los datos cargados y procesados

        // --- DATA LOADING AND PROCESSING ---
        // Parseador para la fecha (formato YYYY-MM-DD)
        const parseDate = d3.timeParse("%Y-%m-%d");

        // Cargar el archivo CSV
        // Asegúrate que 'data.csv' sea el nombre correcto de tu archivo,
        // o usa 'historico_27.06.2025.xlsx - TODO.csv' si no lo renombraste.
        d3.csv("data.csv").then(data => { 
            processedData = data.map(d => {
                return {
                    date: parseDate(d.FECHA), // Usamos solo la columna FECHA
                    open: +d.OPEN,            // Convertimos a número directamente
                    high: +d.MAX,
                    low: +d.MIN,
                    close: +d.CLOSE
                };
            }).filter(d => d.date && !isNaN(d.open) && !isNaN(d.high) && !isNaN(d.low) && !isNaN(d.close)); // Filtra entradas inválidas

            // Ordenar los datos por fecha para asegurar que el gráfico se dibuje correctamente
            processedData.sort((a, b) => a.date - b.date);

            // Una vez que los datos están cargados y procesados, dibuja el gráfico
            drawChart();
            console.log("Datos cargados y procesados (velas diarias):", processedData);

            // --- Ejemplo de cómo obtener el último día (el "más reciente") ---
            if (processedData.length > 0) {
                const mostRecentCandle = processedData[processedData.length - 1]; // La última vela es la más reciente
                
                console.log(`Vela más reciente (${d3.timeFormat("%d/%m/%Y")(mostRecentCandle.date)}):`);
                console.log("Open:", mostRecentCandle.open.toFixed(4));
                console.log("High:", mostRecentCandle.high.toFixed(4));
                console.log("Low:", mostRecentCandle.low.toFixed(4));
                console.log("Close:", mostRecentCandle.close.toFixed(4));

                // Si quieres mostrar esto en el HTML, puedes agregar un div:
                /*
                <div id="info-most-recent"></div>
                */
                // Y luego:
                // document.getElementById('info-most-recent').innerHTML = `
                //     <p><strong>Vela más reciente (${d3.timeFormat("%d/%m/%Y")(mostRecentCandle.date)}):</strong></p>
                //     <ul>
                //         <li>Open: ${mostRecentCandle.open.toFixed(4)}</li>
                //         <li>Close: ${mostRecentCandle.close.toFixed(4)}</li>
                //         <li>High: ${mostRecentCandle.high.toFixed(4)}</li>
                //         <li>Low: ${mostRecentCandle.low.toFixed(4)}</li>
                //     </ul>
                // `;
            }

        }).catch(error => {
            console.error('Error al cargar o procesar el CSV:', error);
            document.getElementById('chart-container').innerHTML = '<p style="color: red;">Error al cargar los datos del gráfico. Asegúrate de que el archivo CSV exista y tenga el formato correcto.</p>';
        });


        // --- NOTA: La función findClosestCandleToTime ya no tiene sentido si solo hay velas diarias.
        // Si quisieras la vela "más cercana a una fecha específica", solo buscarías por fecha.
        // La vela más reciente es simplemente la última del array ordenado.


        // --- SCALES & AXES ---
        const x = d3.scaleBand().padding(0.2);
        const y = d3.scaleLinear();
        // Ajustar el formato del tick del eje X para mostrar solo la Fecha
        const xAxis = d3.axisBottom(x).tickFormat(d3.timeFormat("%d-%b-%Y")); 
        const yAxis = d3.axisLeft(y).tickFormat(d => `${d.toFixed(4)}`); // Aumentar precisión si es necesario
        
        const xAxisGroup = g.append("g").attr("class", "x-axis");
        const yAxisGroup = g.append("g").attr("class", "y-axis");
        const yGridLines = g.append("g").attr('class', 'grid');
        const yAxisLabel = g.append("text").attr("class", "axis-label");
        
        // --- UI ELEMENTS ---
        const clipPath = svg.append("defs").append("clipPath").attr("id", "clip").append("rect");
        const chartBody = g.append("g").attr("clip-path", "url(#clip)");
        const tooltip = d3.select("body").append("div").attr("class", "tooltip");
        const crosshair = g.append('g').style('display', 'none');
        crosshair.append('line').attr('class', 'crosshair crosshair-x');
        crosshair.append('line').attr('class', 'crosshair crosshair-y');
        
        let lastTransform = d3.zoomIdentity;
        const interactionRect = g.append("rect").style("fill", "none").style("pointer-events", "all");
        
        // --- DRAWING FUNCTION ---
        function drawChart() {
            // Solo dibujar si processedData tiene elementos
            if (processedData.length === 0) {
                console.warn("No hay datos para dibujar el gráfico.");
                return;
            }

            width = container.clientWidth - margin.left - margin.right;
            height = (container.clientWidth * 0.5 > 600 ? 600 : container.clientWidth * 0.5) - margin.top - margin.bottom;
            
            svg.attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom);
            clipPath.attr("width", width).attr("height", height);
            interactionRect.attr("width", width).attr("height", height);

            x.domain(processedData.map(d => d.date)).range([0, width]);
            
            const yMin = d3.min(processedData, d => d.low);
            const yMax = d3.max(processedData, d => d.high);

            if (yMin !== undefined && yMax !== undefined) {
                const padding = (yMax - yMin) * 0.1 || yMin * 0.1; 
                y.domain([yMin - padding, yMax + padding]).range([height, 0]);
            } else {
                y.domain([8.9, 9.5]).range([height, 0]); // Default domain si los datos están vacíos
            }
            
            yAxisLabel
                .attr("transform", "rotate(-90)")
                .attr("y", 0 - margin.left + 15)
                .attr("x", 0 - (height / 2))
                .text("Precio (Bs por USD)");

            xAxisGroup.attr("transform", `translate(0,${height})`).call(xAxis);
            yAxisGroup.call(yAxis);
            yGridLines.call(d3.axisLeft(y).tickSize(-width).tickFormat("")).selectAll("line").attr("class", "tick");
            yGridLines.select(".domain").remove();
            
            updateTicks(); 

            chartBody.selectAll("g.candle").remove(); // Limpiar velas antiguas antes de redibujar
            const candles = chartBody.selectAll("g.candle").data(processedData, d => d.date).enter().append("g").attr("class", "candle");
            candles.append("line").attr("class", "wick");
            candles.append("rect").attr("class", "body");
            updateCandlePositions(x);

            svg.call(zoom.transform, d3.zoomIdentity);
        }
        
        function updateCandlePositions(scale) {
             g.selectAll(".candle .wick")
                .attr("x1", d => scale(d.date) + scale.bandwidth() / 2).attr("x2", d => scale(d.date) + scale.bandwidth() / 2)
                .attr("y1", d => y(d.high)).attr("y2", d => y(d.low))
                .attr("stroke", d => d.close >= d.open ? "#26A69A" : "#EF5350");
                
            g.selectAll(".candle .body")
                .attr("x", d => scale(d.date)).attr("y", d => y(Math.max(d.open, d.close)))
                .attr("width", scale.bandwidth()).attr("height", d => Math.abs(y(d.open) - y(d.close)) || 1)
                .attr("fill", d => d.close >= d.open ? "#26A69A" : "#EF5350");
        }

        function updateTicks(scale) {
            if (!scale) scale = x;
            const tickCount = Math.floor(width / 120); // Número aproximado de ticks

            const visibleDataDates = processedData
                .filter(d => {
                    const pos = scale(d.date);
                    return pos !== undefined && pos >= 0 && pos < width;
                })
                .map(d => d.date);
            
            if (visibleDataDates.length === 0) {
                xAxis.tickValues([]);
                xAxisGroup.call(xAxis.scale(scale));
                return;
            }

            // D3 time ticks para fechas diarias (ajusta si quieres un tick por día, o cada N días)
            const timeInterval = d3.timeDay.every(1); // Muestra un tick por cada día
            const tickValues = timeInterval.range(visibleDataDates[0], d3.timeDay.offset(visibleDataDates[visibleDataDates.length - 1], 1));
            
            xAxis.tickValues(tickValues);
            xAxisGroup.call(xAxis.scale(scale));
        }


        // --- INTERACTION HANDLERS ---
        function handleMouseMove(event) {
            if(processedData.length === 0) return;
            const logicalX = lastTransform.invertX(d3.pointer(event)[0]);
            
            // Encuentra la fecha más cercana al puntero
            const closestDate = x.domain().reduce((prev, curr) => {
                return (Math.abs(x(curr) + x.bandwidth() / 2 - logicalX) < Math.abs(x(prev) + x.bandwidth() / 2 - logicalX) ? curr : prev);
            });
            
            // Encuentra el objeto de datos correspondiente a esa fecha
            const d = processedData.find(item => item.date.getTime() === closestDate.getTime());
            
            if (!d) return;

            const [mx, my] = d3.pointer(event);
            const currentXScale = lastTransform.rescaleX(x);
            crosshair.style('display', null);
            crosshair.select('.crosshair-x').attr('x1', 0).attr('x2', width).attr('y1', my).attr('y2', my);
            const crosshairCenterX = currentXScale(d.date) + currentXScale.bandwidth() / 2;
            crosshair.select('.crosshair-y').attr('x1', crosshairCenterX).attr('x2', crosshairCenterX).attr('y1', 0).attr('y2', height);
            
            tooltip.style("opacity", .9);
            const colorClass = d.close >= d.open ? "color-up" : "color-down";
            tooltip.html(`
                <div class="tooltip-date">${d3.timeFormat("%A, %b %d, %Y")(d.date)}</div> <div class="tooltip-info">
                    <span class="${colorClass}">Open:</span><span class="value">${d.open.toFixed(4)}</span><br>
                    <span class="${colorClass}">High:</span><span class="value">${d.high.toFixed(4)}</span><br>
                    <span class="${colorClass}">Low:</span><span class="value">${d.low.toFixed(4)}</span><br>
                    <span class="${colorClass}">Close:</span><span class="value">${d.close.toFixed(4)}</span>
                </div>
            `).style("left", (event.pageX + 15) + "px").style("top", (event.pageY - 28) + "px");
        }

        function handleMouseOut() {
            tooltip.style("opacity", 0);
            crosshair.style('display', 'none');
        }

        // --- ZOOM ---
        function zoomed(event) {
            lastTransform = event.transform;
            const newX = lastTransform.rescaleX(x);
            updateCandlePositions(newX);
            updateTicks(newX);
        }

        const zoom = d3.zoom().scaleExtent([0.5, 50]).translateExtent([[-width, -Infinity], [width * 10, Infinity]]).on("zoom", zoomed);
        // Aplica el zoom al svg entero
        svg.call(zoom); 
        // El interactionRect para detectar movimientos de mouse y tooltips
        interactionRect.on("mousemove", handleMouseMove).on("mouseout", handleMouseOut);

        // --- INITIALIZATION ---
        // drawChart() ahora se llama dentro del .then() de d3.csv
        window.addEventListener('resize', drawChart);

    </script>
</body>
</html>
